#!/usr/bin/env python3

import argparse
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from ete3 import Tree
from Bio import AlignIO

def get_human_ancestral_nodes(tree_file):
    """
    Get all the ancestral nodes for the Human APOA1
    sequence (species ID: Homo_sapiens_ENSP00000364472).
    Only the nodes with UltraFast Bootstrap and
    aLRT support values greater than 70 are returned.
    """

    # Unique identifier of the Human Sequence
    id = "Homo_sapiens_ENSP00000364472"
    # Load phylogeny data
    tree = Tree(tree_file, format=1)
    # Search for the Human node data
    human_node= tree.search_nodes(name=id)[0]
    # Get all ancestral nodes for the human seq
    ancestors = human_node.get_ancestors()
    # Create a list with the name of all the ancestral nodes
    ancestral_nodes = [node.name.split("/")[0]
                       for node in ancestors]
    # Discard last item (is empty)
    ancestral_nodes = ancestral_nodes[:-1]

    return ancestral_nodes


def filter_gapped_positions(df, alignment):
    '''
    Filters a Dataframe to retain only the rows
    corresponding to the non-gap characters on
    the Human sequence.
    '''

    # Load sequence alignment
    algn = AlignIO.read(alignment, 'fasta')
    # Iterate over each sequence
    for sequence in algn:
        # For the Human sequence
        if sequence.id == "Homo_sapiens_ENSP00000364472":
            # Store the position of the gaps
            gaps = [index for index, position in enumerate(sequence.seq)
                    if position == "-"]
    # Filter the dataframe rows using the gap positions
    df = df.drop(df.index[gaps])

    return df


def get_ancestral_sequence(states, node, alignment):
    """
    Reconstructs the most probable sequence
    (higher posterior probability) for a
    phylogeny node based on the states
    outfile generated by iq-tree.
    """

    # Read the sequence states file as dataFrame
    df = pd.read_csv(states,
                     sep="\t",
                     skiprows=8)  # Skip commentary rows
    # Filter the dataframe to retain only the node of interest
    df = df[df.Node == node]
    # Discard columns without sequence state data
    df = df.iloc[:, 3:]
    # Filter out the gap positions
    df = filter_gapped_positions(df, alignment)

    # Set the possible states (20 amino acid letters)
    states = df.columns
    # Initialize a list to store the reconstructed sequence, and other to save the posterior probability values (for plotting)
    seq = []
    post_prob = []
    # Iterate over the rows of the dataframe
    for row in df.iterrows():
        # Get the column number of the most probable state
        most_probable = np.argmax(row[1])
        # Store the posterior probability (PP)
        probability = np.amax(row[1])
        # Assign character if the PP is greater than 0.5, either assign a gap ("-")
        if probability >= 0.5:
            # Add the most probable state to the sequence
            seq.append(states[most_probable].lstrip("p_"))
        else:
            # Add a gap
            seq.append("-")
        # Store the PP of the most probable states
        post_prob.append(probability)
    # Put together the sequence into a string
    seq = f'>{node}\n{"".join(seq)}'

    # Create a histogram for the posterior probabilities
    sns.histplot(post_prob, bins=20, stat="probability")
    # Save the histogram
    outfile = f"{node}_post_prob.svg"
    plt.savefig(outfile)
    plt.close()

    return seq


def main():
    """Command line argument parser"""

    parser = argparse.ArgumentParser()
    parser.add_argument("states",
                        help="IQ-TREE states outfile")
    parser.add_argument("treefile",
                        help="IQ-TREE phylogeny outfile")
    parser.add_argument("alignment",
                        help="Fasta alignment used to remove gaps")

    # Parse command line arguments
    args = parser.parse_args()
    states, treefile, alignment = args.states, args.treefile, args.alignment
    # Get ancestral nodes
    nodes = get_human_ancestral_nodes(treefile)
    for node in nodes:
        # Get ancestral sequece
        print(get_ancestral_sequence(states, node, alignment))


if __name__ == "__main__":
    main()
